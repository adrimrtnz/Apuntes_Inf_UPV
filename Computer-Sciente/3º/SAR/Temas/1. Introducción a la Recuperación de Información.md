## Recuperación de Información (RI)

Bajo este nombre se engloban las diversa arquitecturas, algoritmos, o sistemas cuyo objetivo es encontrar ciertos elementos entre una gran colección no estructurada de ellos, que satisfacen una información requerida.

![RI](https://wachemo-elearning.net/wp-content/uploads/2022/07/image-123.png)

Trata con la representación, almacenamiento, organización y acceso a la información.

## Objetivos de la RI

* **Objetivos originales**: búsqueda e indexación de documentos.
* **Objetivos actuales**:
	* búsqueda e indexación de documentos.
	* búsqueda en la web.
	* clasificación de textos.
	* arquitecturas de los sistemas.
	* interfaces de usuario.
	* visualización de los datos.
	* filtrado, multilingüismo...

### Consultas y respuestas

Las consultas (*query*) son expresiones booleanas de **términos** que se combinan con operadores lógicos AND, OR y NOT.

### Matriz de incidencia binaria

Para cada término de la colección indica si un documento contiene o no el **término** (palabra): matriz de incidencia binaria término-documento del corpus.

![matriz de incidencia binaria](https://miro.medium.com/max/650/1*eeAAaQfcWZN3-k6w43dU_g.png)

## Índice Invertido

Si el corpus de documentos es muy elevado, y se guarda toda la información en la matriz de indicencia, se guardaría mucha información innecesaria (muchos 0s) ya que habrían muchos documentos donde las diferentes palabras no aparecerían, es decir, la matriz de indicencia es muy dispersa en este caso. Es mejor almacenar solamente los 1s, o dicho de otra forma, solo los documentos donde está esa palabra.

### Definición de índice invertido

Está constituido por dos elementos:
* **Diccionario**: lista de términos distintos que contiene el texto.
* **Lista de ocurrencias** (posting list): para cada término se construye una lista con todos los documentos (identificador numérico **docID**) que lo contienen.

![forward vs inverted index](https://www.researchgate.net/publication/266863129/figure/fig3/AS:295746818592776@1447522944370/The-geographic-scopes-inverted-index-The-inverted-index-is-used-for-fast-document.png)

### Construcción de un índice invertido

![fases de construcción de un índice invertido](https://slideplayer.com/4479841/14/images/slide_1.jpg)

Para la construcción de un índice invertido se necesitan:
* Documentos a indexar.
* De estos se saca la secuencia de tokens
* Se seleccionan o modifican los tokens (por ejemplo, palabras de las que se saca poca imformación como artículos, determinantes... se eliminan)

Se realizan diferentes pasos:
* Paso 1: se genera la secuencia de pares (token, documento).
* Paso 2: ordenar por términos.
* Paso 3: Creación del diccionario y las listas de ocurrencias (posting list).

### Índice simple

Se guarda simplemente el ID del documento y la frecuencia de aparición de dicha palabra. Para **responde a secuencias de palabras** o búsqueda de palabras próximas el índice simple **no sirve**.

Se puede añadir información como posición de la palabra dentro del texto donde aparece.
* Si se requiere apuntar la posición de la palabra en el documento (caracteres o por palabras) se debe construir un ***Full inverted index***.

## Procesado Booleano de Consultas

### Consultas de un único término

* La búsqueda más sencilla es encontrar todas las ocurrencias del término.
* La estructura y búsqueda en el diccionario puede hacerse utilizando estructuras de datos clásicas como: Tablas Hash, Trie, B-tree, ...
* Normalmente el diccionario puede caber en memoria central, mientras que las ***posting list*** se almacenan en disco (acceso más lento).

### Consultas de más de un término

Podemos considerar dos casos:
* **Operaciones AND (intersección)**: Se debe buscar la aparición de todos los términos de la consulta obteniendo una lista para cada término. Después hay que hacer la **intersección** de las listas para encontrar la solución.
* **Operaciones OR (disyunción)**: Se debe buscar la aparición de todos los términos de la consulta obteniendo una lista para cada término. Después hay que hacer la **unión** de las listas para encontrar la solución.
* Importante: optimizar en función del orden en que se aplican los operadores.