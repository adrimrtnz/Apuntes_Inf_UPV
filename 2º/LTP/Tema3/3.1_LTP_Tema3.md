# Tema 3: Paradigma funcional

La **Currificación**, permite entre, otras cosas, la aplicación parcial. La **aplicación parcial** solo tiene sentido en el **orden superior**, que es el tratar a las funciones con el mismo nivel que los argumentos, la capacidad de que una función pueda recibir como parámetro otra función.

## Tipos en programación funcional
### 1. Tipos funcionales. Tipos algebraicos
El operador `->`(constructor de tipos) es **asociativo por la derecha**

La función `a -> b -> c` equivale a `a -> (b -> c)`.

Sin embargo el **operador de aplicación** es **asociativo por la izquierda**. La función `f a b` equivale a `(f a) b` y **NO** a `f (a b)` .

A continuación definimos un **árbol** que acepte cualquier número de hojas (*NI = nodo interno*):

```haskell
data Arbol = Hoja Int | NI Int [Arbol]
```

`Hoja Int` hace referencia al caso base. Recordemos que `[]`hace referencia a una lista, es decir, a cualquier número de árboles.

Definimos una función para buscar un valor dentro del árbol:

```haskell
buscarValor:: Arbol Int -> Bool
buscarValor (Hoja x) v = (x == v)
buscarValor (NI x a1 a1) v = (x==v) || buscarValor (a1) v 
									|| buscarValor (a2) v
```

Podemos definir datos de modo polimórfico, y se llaman **tipos de datos paramétricos**:

```haskell
data Arbol a b = Hoja a | NI b Arbol Arbol
```

Siendo **a** y **b** variables de un tipo cualquiera. Al ser polimórficas hay que declararlas junto con el tipo, como hemos hecho con `data Arbol a b`.

### 2. Tipos predefinidos

Son los mismo que en Java u otros lenguajes, lo importante y potente son las funciones que nos aporta Haskell para trabajar con estos tipos.

```haskell
ordenar:: Int -> Int -> Int -> (Int, Int, Int)
ordenar (x y z) | x <= y && y <= x = (x,y,z)
				| x > y && y <= z && x < z = (y, x, z)
				| (etc.)
```

**Ejercicio**: Define una función `siglet:: Char -> Char` que transforme cada letra del alfabeto en la letra siguiente, dejando invariantes los restantes caracteres. Suponemos que debe cumplirse `siglet 'Z'='A'` y `siglet 'z'='a' `.

```haskell
import Data.Char

siglet:: Char -> Char
siglet c | siglet 'z' = 'a'
		 | siglet 'Z' = 'A'
		 | isAlpha(c) = chr (1 + ord c)
		 | otherwise = c
```

**Ejercicio 2**: Crear una función que devuelva la edad dándole la fecha de nacimiento y la fecha actual:

```haskell
edad:: (Int, Int, Int) -> (Int, Int, Int) -> Int
edad (dn,mn,an) (dh, mh, ay) | (mh > mn) || (mh == mm && ah > an) = ah - an 
							 | otherwise = ah - an - 1
```

**Ejercicio 3**: Sean sigma y pi las funciones especificadas como:
$$
\text{sigma f a b} = \sum_{a \le i \le b} \text{ f i} \\
\text{pi f a b} = \prod_{a \le i \le b} \text{ f i} \\
$$
Construye definiciones recursivas ejecutables para las dos funciones, incluyendo declaraciones de tipo:

```haskell
sigma :: Int -> Int -> Int -> Int
sigma f x y | x > y = sigma f y x
			| x == y = f * x
			| x < y = f*x + sigma f (x + 1) y

pi :: Int -> Int -> Int -> Int
pi f x y | x > y = pi f y x
		 | x == y = f * x
		 | x < y = f*x * sigma f (x + 1) y
```



#### Listas intensionales

La notación de **listas intensionales** se inspira en las expresiones utilizadas habitualmente en matemáticas para expresar conjuntos.

##### Diferentes Funciones en Haskell con listas intensionales

```haskell
--filter: devuelve una lista con los elementos de una lista que cumplen cierta condición
filter:: [Int]->(Int->Bool)->[Int]
filter l p = [x | x<-l, px == True]
filter[1,2,3,4](>2) = [3,4]

--pertenece: devuelve si un elemento está o no en una lista
pertenece:: Int->[Int] -> Bool
pertenece x l = [ y | y<-l, y == x ] /= []
pertenece 3 [1,2,4] -> False

--repetir: devuelve una lista de un elemento x repetido y veces
repetir:: Int->Int->[Int]
repetir x y = [ x | z<-[1..y] ]
repetir 3 5 = [3,3,3,3,3]

--divisores
divisores:: Int->[Int]
divisores x = [y | y<-[1..x], mod x y == 0]

--primos: define una lista infinita; deberíamos gastar, por ejemplo -> take N_primos primos
primos = [x | x <- [1..], length (divisores x) <= 2]
```



En la definición de este tipo de listas, el primer elemento es el elemento *retornado*, en el caso de la función repetir, por cada elemento de `z<-[1..y]` devuelve el elemento `x`, de este modo devuelve la lista esperada.



**Ejercicio**: Define una función que compruebe si una lista de enteros está ordenada:

```haskell
ordenada:: [Int] -> Bool
--casos base
ordenada [] = True
ordenada [x] = True

--A (versión pizarra)
ordenada (x:y:resto) | x <= y = ordenada (y:resto)
					 | x > y = False

--B (versión otro alumno alternativa a A)
ordenada (x:y:resto) = x <= y && ordenada(y:resto)

-- esta versión usa funciones no vistas en clase
ordenada x | length x == 0 || length x == 1 = True
		   | x !! 0 <= x !! 1 = ordenada (tail x)		   
```

**Ejercicio**: Define una función que cree una lista de n copias de su parámetro x:

```haskell
-- igual que el repetir pero más general, no solo para enteros
copias a -> a -> Int -> [Int]
copias x y = [x | z <- [1..y]]
```

**Ejercicio**: Definir una función posición que indique la (primera) posición que ocupa un elemento en una lista:

```haskell
position :: a -> [a] -> Int
position e lista = head [z | (y,z) <- zip lista [1..], y == e]
```

**Ejercicio**: Definir una función que calcule la longitud de un camino:

```haskell
type Point = (Float,Float)
type Path = [Point]
examplePath = [p, q, r, s]

-- pathLength = distance p q + distance q r + distance r s
-- sqrt = raíz cuadrada
-- sqr  = elevar al cuadrado
distance :: Point -> Point -> Float
distance (a1,a2) (b1,b2) =  sqrt ( sqr(b1-a1) + sqr(b2-a2) ) 

pathLength :: Path -> Float

-- con lista intensional
pathLength x = sum [distance a b | (a,b)<-zip(init x, tail x)]

-- con la que hace falta la siguiente definición de sum
sum :: [Float] -> Float
sum [] = 0
sum (x:xs) = x + (sum xs)

-- con recursión
pathLength [] = 0
pathLength list = distance (head list) (head (tail list)) + pathLength (tail list)		
```



**Ejercicio**: programación de **mergeSort** (por simplicidad la hacemos solo con Enteros):

1. Dividir la lista en dos partes iguales.
2. Ordenar cada parte.
3. Poner juntas las dos mitades ordenadas.

```haskell
mergeSort :: [Int] -> [Int]

-- casos base
mergeSort [] = []
mergeSort [x] = [x]
				
mergeSort xs | size > 0 = 
	merge (mergeSort mitad1) (mergeSort mitad2)
		where longitud = length lista
			centro   = div longitud 2 	-- el div es para la división entera
          	mitad1   = take centro lista  -- take coge n elementos del principio
          	mitad2   = drop centro lista  -- drop coge n elementos desde el final

-- función necesaria para el mergeSort (diapositivas pg. 54)
-- a@ y b@ hace referencia al alias o seudónimo de un patrón
merge :: [Int] -> [Int] -> [Int]
merge [] ys = ys
merge xs [] = xs
merge a@(x:xs) b@(y:ys) | x <= y = x: merge xs b
						| otherwise y : merge a ys
```



### 3. Polimorfismo. Herencia en Haskell

## Modelos de computación funcional
### 4. Modelo operacional

## Características avanzadas
### 5. Funciones anónimas y composiciones de funciones

### 6. Iteradores y compresores (foldl, foldr)